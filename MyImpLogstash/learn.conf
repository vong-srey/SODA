input { stdin { } }

filter {


	grok { 


		# write the biggest number of data on the top

		# Process log pattern
		match => [ "message", "%{SODATIME:logtime} %{DEVICE_NAME:dev} %{USERNAME:UsrName} %{USERNAME:OwnrGrp} %{STARTTIME:start} %{NUMBER:CpuSysTime} %{NUMBER:CpuUsrTime} %{NUMBER:CpuUsg} %{WORD:State} %{NUMBER:NumActiveThreads} %{NUMBER:Priority} %{NUMBER:Nice} %{NUMBER:SharedMem} %{NUMBER:RssMem} %{NUMBER:VirtualMem} %{NUMBER:NonIOpgFaults} %{NUMBER:TotalPgFaults}"]

		# network log pattern
		match => [ "message", "%{SODATIME:logtime} %{DEVICE_NAME:dev} %{NUMBER:ActConOpn} %{NUMBER:PssConOpn} %{NUMBER:FailedConAtmpt} %{NUMBER:ConRstRcv} %{NUMBER:ConEstbl} %{NUMBER:PcktsRcv} %{NUMBER:PcktsSent} %{NUMBER:PcktsRetrnsmt} %{NUMBER:BadPcktsRcv} %{NUMBER:PcktsRstSent}"]

		# cpu log pattern
		match => [ "message", "%{SODATIME:logtime} %{DEVICE_NAME:dev} %{NUMBER:User} %{NUMBER:Sys} %{NUMBER:Idle} %{NUMBER:Wait} %{NUMBER:Nice} %{NUMBER:Combined} %{NUMBER:IRQ}" ]

		#memory
		match => [ "message", "%{SODATIME:logtime} %{DEVICE_NAME:dev} %{NUMBER:Mem-total} %{NUMBER:Mem-used} %{NUMBER:Mem-free} %{NUMBER:Swap-total} %{NUMBER:Swap-used} %{NUMBER:Swap-free}" ]

		# df log pattern
		match => [ "message", "%{SODATIME:logtime} DF-%{DEVICE_NAME:dev} %{NUMBER:Size} %{NUMBER:Used} %{NUMBER:Avail} %{NUMBER:Used-Perc}" ]

		#disk
		match => [ "message", "%{SODATIME:logtime} Disk-%{DEVICE_NAME:dev} %{NUMBER:R-in} %{NUMBER:W-out} %{NUMBER:Data-r} %{NUMBER:Data-w}" ]






			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
			# # # #                        Patterns for GC Logs                     # # # # 
			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 

		# Full GC Pattern (this must come before GC pattern)
		match => ["message", "%{NUMBER:FullGCTime}: \[Full GC \[%{WORD}: %{NUMBER}K->%{NUMBER}K\(%{NUMBER}K\)\] \[%{WORD}: %{NUMBER}K->%{NUMBER}K\(%{NUMBER}K\)\] %{NUMBER}K->%{NUMBER:HeapUsg-FullGC}K\(%{NUMBER}K\) \[%{WORD}: %{NUMBER}K->%{NUMBER}K\(%{NUMBER}K\)\], %{NUMBER:STW-FullGC} secs\] \[Times: user=%{NUMBER} sys=%{NUMBER}, real=%{NUMBER} secs\]"]
	
		# GC Pattern
		match => ["message", "%{NUMBER:GCTime}: \[GC \[%{WORD}: %{NUMBER}K->%{NUMBER}K\(%{NUMBER}K\)\] %{NUMBER}K->%{NUMBER:HeapUsg-GC}K\(%{NUMBER}K\), %{NUMBER:STW-GC} secs\] \[Times: user=%{NUMBER} sys=%{NUMBER}, real=%{NUMBER} secs\]"]







			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
			# # # #                        Patterns for Access Logs                 # # # # 
			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 

		# Access Log pattern for Internet Explorer (contains keywords:  MSIE %{BROWSER_VERSION} ... WOW64 ... Trident)
		match => ["message", "%{IPV4} \[%{HTTPDATE:logtime}\] %{BASE16NUM:SessionID} \"(?:(GET)|(POST)) %{URIPATH:Uri}(%{URIPARAM}*) HTTP/%{NUMBER}\" %{NUMBER:RespCode} %{NUMBER:ByteSent} %{NUMBER:ReqProcTime} %{THREAD_NAME} %{UAGS}MSIE %{BROWSER_VERSION:IEVersion}(%{UAGS}*)((WOW64)*)(%{UAGS}*)((Trident)*)"]

		# Access Log pattern for Firefox (contains keywords:  Firefox/%{BROWSER_VERSION})
		match => ["message", "%{IPV4} \[%{HTTPDATE:logtime}\] %{BASE16NUM:SessionID} \"(?:(GET)|(POST)) %{URIPATH:Uri}(%{URIPARAM}*) HTTP/%{NUMBER}\" %{NUMBER:RespCode} %{NUMBER:ByteSent} %{NUMBER:ReqProcTime} %{THREAD_NAME} %{UAGS}Firefox/%{BROWSER_VERSION:FirefoxVersion}"]

		# Access Log pattern for Chrome     (contains keywords:  Chrome/%{BROWSER_VERSION} blah blah blah Safari/${BROWSER_VERSION})
		match => ["message", "%{IPV4} \[%{HTTPDATE:logtime}\] %{BASE16NUM:SessionID} \"(?:(GET)|(POST)) %{URIPATH:Uri}(%{URIPARAM}*) HTTP/%{NUMBER}\" %{NUMBER:RespCode} %{NUMBER:ByteSent} %{NUMBER:ReqProcTime} %{THREAD_NAME} %{UAGS}Chrome/%{BROWSER_VERSION:ChromeVersion}(%{UAGS}*)((Safari)*)"]

		# Access Log pattern for Safari (contains keywords:  Safari/%{BROWSER_VERSION}) 
		match => ["message", "%{IPV4} \[%{HTTPDATE:logtime}\] %{BASE16NUM:SessionID} \"(?:(GET)|(POST)) %{URIPATH:Uri}(%{URIPARAM}*) HTTP/%{NUMBER}\" %{NUMBER:RespCode} %{NUMBER:ByteSent} %{NUMBER:ReqProcTime} %{THREAD_NAME} %{UAGS}Safari/%{BROWSER_VERSION:SafariVersion}"]
	}	


			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
			# # # #                   Mutate fields for Access Logs                 # # # # 
			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 

			# dropping version and make a unified Browser field
	if [SafariVersion] {
		mutate{
			add_field => {"Browser" => "Safari-v.%{SafariVersion}"}
			remove_field => ["SafariVersion"]
		}	
	}
	if [ChromeVersion] {
		mutate{
			add_field => {"Browser" => "Chrome-v.%{ChromeVersion}"}
			remove_field => ["ChromeVersion"]
		}	
	}
	if [FirefoxVersion] {
		mutate{
			add_field => {"Browser" => "Firefox-v.%{FirefoxVersion}"}
			remove_field => ["FirefoxVersion"]
		}	
	}
	if [IEVersion] {
		mutate{
			add_field => {"Browser" => "IE-v.%{IEVersion}"}
			remove_field => ["IEVersion"]
		}	
	}
	





	# if the log can be matched to pattern
	if "_grokparsefailure" not in [tags]{
		date{
			match => ["logtime", "dd/MMM/YYYY-HH:mm:ss.SSS", "dd MMM YYYY HH:mm:ss.SSS", "dd/MMM/YYYY:HH:mm:ss Z", "dd MMM YYYY:HH:mm:ss Z"]

			# logtime has been replaced by logstash's @timestamp instead. so, its safe to remove
			# message has been broken down by regex. so, its a wast to keep it. 
			remove_field => ["logtime", "message", "@version"]
		
			# should we remove the host field?
	
			# set timezone to UTC (+00:00), in order to prevent Grok to offset the given logtime 
			timezone => "UTC"

		}

	# if the log cannot be matched to pattern
	} else {
		mutate {  
			remove_field => ["@version", "tags"]
		}	
	}




 

}

output {
	elasticsearch { host => localhost }
	stdout { codec => rubydebug }
}

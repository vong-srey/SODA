#for detail of the patterns, please find them in logstash/patterns/grok-patterns or logstash/patterns/soda-patterns

input { stdin { } }

filter {


	grok { 



		# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
		# # # #                        Patterns for System Logs                 # # # # 
		# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 

		# write the biggest number of data on the top

		# Process log pattern
		match => [ "message", "%{SODADATE:logtime} %{DEVICE_NAME:dev} %{USERNAME:UsrName} %{USERNAME:OwnrGrp} %{STARTTIME:start} %{NUMBER:CpuSysTime} %{NUMBER:CpuUsrTime} %{NUMBER:CpuUsg} %{WORD:State} %{NUMBER:NumActiveThreads} %{NUMBER:Priority} %{NUMBER:Nice} %{NUMBER:SharedMem} %{NUMBER:RssMem} %{NUMBER:VirtualMem} %{NUMBER:NonIOpgFaults} %{NUMBER:TotalPgFaults}"]

		# network log pattern
		match => [ "message", "%{SODADATE:logtime} %{DEVICE_NAME:dev} %{NUMBER:ActConOpn} %{NUMBER:PssConOpn} %{NUMBER:FailedConAtmpt} %{NUMBER:ConRstRcv} %{NUMBER:ConEstbl} %{NUMBER:PcktsRcv} %{NUMBER:PcktsSent} %{NUMBER:PcktsRetrnsmt} %{NUMBER:BadPcktsRcv} %{NUMBER:PcktsRstSent}"]

		# cpu log pattern
		match => [ "message", "%{SODADATE:logtime} %{DEVICE_NAME:dev} %{NUMBER:User} %{NUMBER:Sys} %{NUMBER:Idle} %{NUMBER:Wait} %{NUMBER:Nice} %{NUMBER:Combined} %{NUMBER:IRQ}" ]

		#memory
		match => [ "message", "%{SODADATE:logtime} %{DEVICE_NAME:dev} %{NUMBER:Mem-total} %{NUMBER:Mem-used} %{NUMBER:Mem-free} %{NUMBER:Swap-total} %{NUMBER:Swap-used} %{NUMBER:Swap-free}" ]

		# df log pattern
		match => [ "message", "%{SODADATE:logtime} DF-%{DEVICE_NAME:dev} %{NUMBER:Size} %{NUMBER:Used} %{NUMBER:Avail} %{NUMBER:Used-Perc}" ]

		#disk
		match => [ "message", "%{SODADATE:logtime} Disk-%{DEVICE_NAME:dev} %{NUMBER:R-in} %{NUMBER:W-out} %{NUMBER:Data-r} %{NUMBER:Data-w}" ]






			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
			# # # #                        Patterns for GC Logs                     # # # # 
			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 

		# STW : Stop The World

		# Full GC Pattern (this must come before GC pattern)
		match => ["message", "%{NUMBER:FullGCTime}: \[Full GC \[%{WORD}: %{NUMBER}K->%{NUMBER}K\(%{NUMBER}K\)\] \[%{WORD}: %{NUMBER}K->%{NUMBER}K\(%{NUMBER}K\)\] %{NUMBER}K->%{NUMBER:HeapUsg-AterGC}K\(%{NUMBER}K\) \[%{WORD}: %{NUMBER}K->%{NUMBER}K\(%{NUMBER}K\)\], %{NUMBER:STW-Time} secs\] \[Times: user=%{NUMBER} sys=%{NUMBER}, real=%{NUMBER} secs\]"]
	
		# GC Pattern
		match => ["message", "%{NUMBER:GCTime}: \[GC \[%{WORD}: %{NUMBER}K->%{NUMBER}K\(%{NUMBER}K\)\] %{NUMBER}K->%{NUMBER:HeapUsg-AfterGC}K\(%{NUMBER}K\), %{NUMBER:STW-Time} secs\] \[Times: user=%{NUMBER} sys=%{NUMBER}, real=%{NUMBER} secs\]"]








			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
			# # # #                     Patterns for Event Logs                     # # # # 
			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 


		match => [ "message", "%{SODADATE:EndTime} \| END %{OHP_EVENTTYPE:EventType} \'%{NUMBER} %{THREAD_NAME}\' \'%{OHP_EVN_PARAM:Param}\' %{NUMBER:ReqProcTime}"]






			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
			# # # #                        Patterns for Access Logs                 # # # # 
			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 

		#UAGS : User Agent String. it is used to grab all the chars sets that we don't want to include

		# Access Log pattern for Internet Explorer (contains keywords:  MSIE %{BROWSER_VERSION} ... WOW64 ... Trident)
		match => ["message", "%{IPV4} \[%{HTTPDATE:logtime}\] %{BASE16NUM:SessionID} \"(?:(GET)|(POST)) %{URIPATH:Uri}(%{URIPARAM}*) HTTP/%{NUMBER}\" %{NUMBER:RespCode} %{NUMBER:ByteSent} %{NUMBER:ReqProcTime} %{THREAD_NAME} %{UAGS}MSIE %{BROWSER_VERSION:IEVersion}(%{UAGS}*)((WOW64)*)(%{UAGS}*)((Trident)*)"]

		# Access Log pattern for Firefox (contains keywords:  Firefox/%{BROWSER_VERSION})
		match => ["message", "%{IPV4} \[%{HTTPDATE:logtime}\] %{BASE16NUM:SessionID} \"(?:(GET)|(POST)) %{URIPATH:Uri}(%{URIPARAM}*) HTTP/%{NUMBER}\" %{NUMBER:RespCode} %{NUMBER:ByteSent} %{NUMBER:ReqProcTime} %{THREAD_NAME} %{UAGS}Firefox/%{BROWSER_VERSION:FirefoxVersion}"]

		# Access Log pattern for Chrome     (contains keywords:  Chrome/%{BROWSER_VERSION} blah blah blah Safari/${BROWSER_VERSION})
		match => ["message", "%{IPV4} \[%{HTTPDATE:logtime}\] %{BASE16NUM:SessionID} \"(?:(GET)|(POST)) %{URIPATH:Uri}(%{URIPARAM}*) HTTP/%{NUMBER}\" %{NUMBER:RespCode} %{NUMBER:ByteSent} %{NUMBER:ReqProcTime} %{THREAD_NAME} %{UAGS}Chrome/%{BROWSER_VERSION:ChromeVersion}(%{UAGS}*)((Safari)*)"]

		# Access Log pattern for Safari (contains keywords:  Safari/%{BROWSER_VERSION}) 
		match => ["message", "%{IPV4} \[%{HTTPDATE:logtime}\] %{BASE16NUM:SessionID} \"(?:(GET)|(POST)) %{URIPATH:Uri}(%{URIPARAM}*) HTTP/%{NUMBER}\" %{NUMBER:RespCode} %{NUMBER:ByteSent} %{NUMBER:ReqProcTime} %{THREAD_NAME} %{UAGS}Safari/%{BROWSER_VERSION:SafariVersion}"]

	} # grok ends here








			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
			# # # #                   Mutate fields for Access Logs                 # # # # 
			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 

			# dropping version and make a unified Browser field
	if [SafariVersion] {
		mutate {
			add_field => {"Browser" => "Safari-v.%{SafariVersion}"}
			remove_field => ["SafariVersion"]
		}	
	}
	if [ChromeVersion] {
		mutate {
			add_field => {"Browser" => "Chrome-v.%{ChromeVersion}"}
			remove_field => ["ChromeVersion"]
		}	
	}
	if [FirefoxVersion] {
		mutate {
			add_field => {"Browser" => "Firefox-v.%{FirefoxVersion}"}
			remove_field => ["FirefoxVersion"]
		}	
	}
	if [IEVersion] {
		mutate {
			add_field => {"Browser" => "IE-v.%{IEVersion}"}
			remove_field => ["IEVersion"]
		}	
	}
	





			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
			# # # #                 Calculate timestamp for Event log               # # # # 
			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 

	# in Event log, we can get the EndTime
	# this ruby code, try to compute @timestamp for this log (this is the Start Time of the query)
	if [EndTime] {
		ruby {
			code => "
					event['EndTime'] = Time.parse(event['EndTime'])
					event['@timestamp'] = event['EndTime'] - event['ReqProcTime'].to_i
				"
		}
	}








	# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
	# # # #             Calculate timestamp for GC and FUllGC log           # # # # 
	# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 

	if [GCTime] {
		ruby {
			code => "
					t = Time.now
					event['@timestamp'] = Time.new(t.year, t.month, t.day) + event['GCTime'].to_f
					event['Type'] = 'GC'
				"
		}
		mutate {
			remove_field => ["GCTime"]
		}
	}

	if [FullGCTime] {
		ruby {
			code => "
					t = Time.now
					event['@timestamp'] = Time.new(t.year, t.month, t.day) + event['FullGCTime'].to_f
					event['Type'] = 'FullGC'
				"
		}
		mutate {
			remove_field => ["FullGCTime"]
		}
	}





			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
			# # # #        Mutate timestampe and removing unnecessary fileds        # # # # 
			# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 

	# if the log can be matched to pattern
	if "_grokparsefailure" not in [tags]{
		date{
			match => ["logtime", "dd/MMM/YYYY-HH:mm:ss.SSS", "dd MMM YYYY HH:mm:ss.SSS","dd/MMM/YYYY-HH:mm:ss,SSS", "dd MMM YYYY HH:mm:ss,SSS", "dd/MMM/YYYY:HH:mm:ss Z", "dd MMM YYYY:HH:mm:ss Z", "YYYY-MM-dd'T'HH:mm:ss.SSSZ"]

			# logtime has been replaced by logstash's @timestamp instead. so, its safe to remove
			# message has been broken down by regex. so, its a wast to keep it. 
			remove_field => ["logtime", "message", "@version"]
		
			# should we remove the host field?
	
			# set timezone to UTC (+00:00), in order to prevent Grok to offset the given logtime 
			timezone => "UTC"

		}

	# if the log cannot be matched to pattern
	} else {
		mutate {  
			remove_field => ["@version", "tags"]
		}
	}




 

} #Filter ends here

output {
	elasticsearch { host => localhost }
	stdout { codec => rubydebug }
}
